/*! 
* \file yangxq.h 
* \brief Prototypes and definition for memory manager application library
*  
* \This program is free software; you can redistribute it and/or modify      
* \Description: The memory manager library will choice use MRAM or NAND      
* \flash by policy.                                                          
* \The fixed selection feature of MRAM and NAND Flash is the current         
* \development item.                                                         
* \The memory manager library will supply user malloc and mmap two sorts     
* \of API.  
* \author xxx 
* \version 1.0.0.0 
* \date 2017.8.2 
*/  


#include <sys/mman.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define handle_error(msg)  do {perror(msg); exit(EXIT_FAILURE);} while (0)  
#define offsetof(TYPE, MEMBER) ((size_t) &((TYPE *)0)->MEMBER)
#define  container_of(ptr, type, member) ({                      \
                      const typeof( ((type *)0)->member ) *__mptr = (ptr);    \
                       (type *)( (char *)__mptr - offsetof(type,member) );})

/**
            * @name The address of the file in the nandflash
            * @{
            */
#define ME_NANDFLASH_DIR  "/home/holic/test/test.XXXXXX"  //"/home/yangxq/test/test.XXXXXX"    // "/home/nandflash_test0"  
/** @} */

/**
            * @name The address of the file in the mram
            * @{
            */
#define ME_MRAM_DIR  "/home/mram_test0"
/** @} */
#define ME_NUMBER  (sizeof(ME_NANDFLASH_DIR)>sizeof(ME_MRAM_DIR)?sizeof(ME_NANDFLASH_DIR):sizeof(ME_MRAM_DIR))
#define ME_SIZE_STRUCTMEMORY sizeof(struct me_memory)


enum me_policy{
	capacity,speed,througput  /// several policy 
};


enum me_hd_type{
	nandflash,mram            ///several divice 
};

/**
    * @brief Used to store information that uses memory
    */
struct me_memory{
	enum me_policy policy;    /*!< policy */
	enum me_hd_type hd_type;  /*!< hardware categories */
	int drop;                 /*!< volatite of nonvolatite */
	char dir[ME_NUMBER+1];    /*!< file directory */
	void *addr;               /*!< file address */
	size_t size;              /*!< memory size */
	int fd;                   /*!<file handle */
};


/// \brief Allocate memory to the user
/// \param n1 size  
/// \param c2 policy   
/// \return 返回说明 
/// \	   -<em>null</em> fail
/// \	-<em>memory address</em> succeed
void *memalloc(size_t size, int policy){
	struct me_memory *memory;     /*!< Declare a structure */
	memory = (struct me_memory*)malloc(ME_SIZE_STRUCTMEMORY); /*!< memory address*/
	if (memory == NULL){
		handle_error("memory");
	}
	memory->size = size;
	memory->policy = policy;
	memory->drop = 0;
	off_t pa_offset = 0;
	switch (memory->policy){
		case capacity:
			memory->hd_type = nandflash;
			break;
		case speed:
			memory->hd_type = mram;
			break;
		default:
			handle_error("policy");
			break;
	}
	switch (memory->hd_type){
		case nandflash:
		        memcpy(memory->dir, ME_NANDFLASH_DIR, ME_NUMBER);
			break;			
		case mram:
			memcpy(memory->dir, ME_MRAM_DIR, ME_NUMBER);		
			break;
		default:
			handle_error("hd_type");
			break;
	}
	memory->fd = mkstemp(memory->dir);
	if (-1 == memory->fd){
		handle_error("mkstemp");
	}	
	if (-1 == ftruncate(memory->fd, memory->size+ME_SIZE_STRUCTMEMORY)){
		handle_error("mkstemp");
	}		
	memory->addr = mmap(NULL, memory->size+ME_SIZE_STRUCTMEMORY, PROT_READ|PROT_WRITE, MAP_SHARED, memory->fd, pa_offset);
	if (MAP_FAILED == memory->addr){
		 handle_error("mmap");
	}
	memcpy(memory->addr, memory, ME_SIZE_STRUCTMEMORY);
	free (memory);
	return (memory->addr+ME_SIZE_STRUCTMEMORY);	
}

/** 
    * @brief Free the used memory
    * @param char *ptr   
    *
    */
void mefree(char *ptr){
	struct me_memory *memory_new = ptr-ME_SIZE_STRUCTMEMORY;  /*!< user‘s memory address */
	printf ("memory_new->drop=%d\n",memory_new->drop);
	printf ("memory_new->size=%d\n",memory_new->size);
	if (0 == memory_new->drop){				   /*!< Reserved interface */
		printf ("memory_new->dir=%s\n",memory_new->dir);	
		if (-1 == unlink(memory_new->dir)){
			handle_error("unlink");
		}
		if (-1 == munmap(memory_new->addr, memory_new->size)){
			handle_error("munmap");
		}
	}
}

/// \brief Allocate memory to the user
/// \param n1 *ptr  
/// \param c2 size   
/// \return 返回说明 
/// \	   -<em>null</em> fail
/// \	-<em>memory address</em> succeed
void *merealloc(void *ptr, size_t size){
	struct me_memory *memory_newest = ptr-ME_SIZE_STRUCTMEMORY; /*!< user‘s memory address */
	void *newaddr = memalloc(size, memory_newest->policy);      /*!< new memory address */
	if (newaddr == NULL){
                handle_error("memory");
        }

	void *me_str = memcpy(newaddr, memory_newest->addr, memory_newest->size);
								/*!< Copy content in memory */

	if (-1 == unlink(memory_newest->dir)){
			handle_error("unlink");
	}
	if (-1 == munmap(memory_newest->addr, memory_newest->size)){
			handle_error("munmap");
	}
	return me_str;
}

/*
 function：to move the memory
 
 arg: me_memory         --save user's info
 
 return: new_ptr
 
 */
void *memove(void *ptr, size_t new_size, int new_policy){
	struct me_memory *memory_newest = ptr-ME_SIZE_STRUCTMEMORY;/*!< user‘s memory address */
	new_ptr = memalloc(new_size, new_policy);                  /*!< new memory address */
	memcpy(new_ptr, ptr, memory_newest->size);		   /*!< Copy content in memory */
	mefree(ptr);	
	return new_ptr ;
}


int main(){
	char *str1, *str2;
	str1 = memalloc(100, capacity);
	printf("%p\n",str1);
	str2 = merealloc(str1, 200);
	printf("%p\n",str2);
	mefree(str2);
	return 0;
}
